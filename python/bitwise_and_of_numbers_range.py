"""
# 由数据范围0 <= m <= n <= 2147483647可知，时间复杂度O（n）及以上的解法是不可接受的。
# 因此可以判断此题为数学题。
# 只要有两个数字如果不相等，因为存在奇偶数，那么他们二进制对应的最后一位必然不相等。
# 如： [4,6], 4 是 0100 5是0101, 最后1位不相同则最后的结果必然也是0
# 所以逐步检测不相同然后右移，并统计移了了几次。在本题中的例子中，
# 4 移1次为 0010  5移1次为0010 不相等 offset = 1
# 两个数字再移动1次为 0001  相等 offset = 2
# 那么就把n左移两次即 0001 左移 2 为 0100  （4）
# 可以看出这样移位正式控制了每一个为0的位为0.十分的巧妙！
# 

又是一道考察位操作Bit Operation的题，相似的题目在LeetCode中还真不少，比如Repeated DNA Sequences 
求重复的DNA序列， Single Number 单独的数字,   Single Number II 单独的数字之二 ， Grey Code 格雷码，
和 Reverse Bits 翻转位 等等，那么这道题其实并不难，我们先从题目中给的例子来分析，[5, 7]里共有三个数字，
分别写出它们的二进制为：

101　　110　　111

相与后的结果为100，仔细观察我们可以得出，最后的数是该数字范围内所有的数的左边共同的部分，如果上面那个例子不太明显，
我们再来看一个范围[26, 30]，它们的二进制如下：

11010　　11011　　11100　　11101　　11110

发现了规律后，我们只要写代码找到左边公共的部分即可，我们可以从建立一个32位都是1的mask，然后每次向左移一位，
比较m和n是否相同，不同再继续左移一位，直至相同，然后把m和mask相与就是最终结果
此题还有另一种解法，不需要用mask，直接平移m和n，每次向右移一位，直到m和n相等，记录下所有平移的次数i，
然后再把m左移i位即为最终结果，代码如下：
"""



class Solution:
    # @param {integer} m
    # @param {integer} n
    # @return {integer}
    def rangeBitwiseAnd(self, m, n):
    	offset = 0
    	while m!=n:
    		m = m >> 1
    		n = n >> 1
    		offset += 1
    	return n << offset


"""
我自己的理解：为什么是左边相同位而不是中间或其它地方的， 
因为其他地方不可能所有数字都相同， 只可能高位；左移后面补零， 所以前面是相同的
"""





















